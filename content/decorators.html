---
title: "decorators"
date: 2018-08-12T15:30:35+02:00
draft: false
categories: ["Python"]
tags: ["Python", "decorators"]
---



<div id="what-are-decorators-and-why-would-you-use-them" class="section level2">
<h2>1. What are decorators and why would you use them?</h2>
<ul>
<li><p>decorators in Python are special functions that take a function as an argument and slightly change it’s behaviour, e.g. it’s return value;</p></li>
<li><p>you can write your own decorators, which is rather easy (I highly recommend <a href="http://shop.oreilly.com/product/0636920032519.do">Fluent Python</a> as a reference)</p></li>
<li><p>but there are already many useful decorators available in Python.</p></li>
</ul>
<p>I am not going to describe here how to write your own decorator as, to be honest, I used them only twice in my career. In fact, I didn’t have to do that, I just wanted to try them out ;)</p>
</div>
<div id="useful-built-in-decorators" class="section level2">
<h2>2. Useful built-in decorators</h2>
<div id="property" class="section level3">
<h3><span class="citation">@property</span></h3>
<div id="why-would-you-use-property" class="section level4">
<h4>Why would you use property?</h4>
<p>You crate a class with a specific attribute, say, <code>name</code>. At the beginning you are happy to use it only as:</p>
<pre><code>object.name = &#39;Tomek&#39;
print(object.name)</code></pre>
<p>but after a while you realise that you need something else happening during setting a name and getting a name, something in the background, e.g. printing <em>you’ve just set a name</em> and <em>you’ve just got a name</em>. This would be easy if you had defined separate <code>getters</code> and <code>setters</code>, but you didn’t and there are folks who already use this class, so they wouldn’t be happy if they had to change their code.</p>
<p>So you’re on your own. Here’s how you solve this problem:</p>
<pre class="python"><code>class SomeFolk:
    def __init__(self, name):
        self._name = name
    @property
    def name(self):
        &quot;&quot;&quot;this is just our previous, default behaviour&quot;&quot;&quot;
        return self._name
    @name.setter
    def name(self, name):
        &quot;&quot;&quot;this is our brand new setter&quot;&quot;&quot;
        self._name = name
        print(&quot;you&#39;ve just set a name to {}&quot;.format(self._name))  # log message
    @name.getter
    def name(self):
        &quot;&quot;&quot;this is our brand new getter&quot;&quot;&quot;
        print(&quot;you&#39;ve just got a name&quot;)  # log message
        return self._name</code></pre>
<p>Let’s create an instance of this class:</p>
<pre class="python"><code>me = SomeFolk(&#39;Tomek&#39;)</code></pre>
<p>Here’s what happens when you get a name:</p>
<pre class="python"><code>_some_variable = me.name</code></pre>
<pre><code>## you&#39;ve just got a name</code></pre>
<p>And when you set a name:</p>
<pre class="python"><code>me.name = &quot;tomis9&quot;</code></pre>
<pre><code>## you&#39;ve just set a name to tomis9</code></pre>
<p>Magic.</p>
</div>
</div>
<div id="classmethod-and-staticmethod" class="section level3">
<h3><span class="citation">@classmethod</span> and <span class="citation">@staticmethod</span></h3>
<p>Here’s a great tutorial describing the difference and usage:</p>
<iframe width="853" height="480" src="https://www.youtube.com/embed/rq8cL2XMM5M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</div>
</div>
<div id="todo" class="section level2">
<h2>3. TODO</h2>
<ul>
<li>an example of a self-made decorator</li>
</ul>
</div>
